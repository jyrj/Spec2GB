
---


# Roadmap

| Week  | Mentee A                                                                                                                                                                                                            | Mentee B                                                                                                                                                                    | Mentee C                                                                                                                                                                  |
| ----- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1** | `cpu` spec + prompt<br>• Expand `cpu.alu_ops` with AND, OR, XOR, INC.<br>• Fill `prompts/cpu_template.md` for `reset()` + `step()` (ADD/SUB).<br>• Run prompt via LLM → `generated/cpu.py`.<br>• *(Optional: `tests/test_cpu_smoke.py`.)* | `memory` spec + prompt<br>• Begin `memory.regions` (ROM, VRAM, WRAM, OAM).<br>• Start `prompts/memory_template.md`.<br>• Generate `generated/memory.py`.<br>• *(Optional: `tests/test_mem_bounds.py`.)* | `ppu` spec + prompt<br>• Add `STAT`, `SCY`, `SCX`, `WY`, `WX`.<br>• Write `prompts/ppu_template.md` → `generated/ppu.py`.<br>• Add `tests/test_ppu_regs.py`.                                         |
| **2** | Prompt iteration + branching<br>• Add `JP`, `JR`, `CALL`, `RET` to spec.<br>• Update prompt + regenerate `generated/cpu.py`.<br>• Create `examples/cpu_microdemo.py` that runs 10-byte demo and prints `A`, `F`, `PC`.                    | Finish memory prompt/code<br>• Complete `memory.regions` (ROM0, VRAM, WRAM, OAM, HRAM).<br>• Finalize `memory_template.md`, regenerate `memory.py`.<br>• Add `tests/test_mem_bounds.py`.                | PyBoy harness + test<br>• Build `cosim/pyboy_harness.py` (step ROM 50 cycles, dump `{A,F,PC}`).<br>• Write `tests/test_cpu_vs_pyboy.py`: compare one ADD step.<br>• Demo in `examples/run_pyboy.py`. |
| **3** | Load/store ops<br>• Add `LD r,r'`, `LD A,(n8)`, `LD (n8),A`, `INC A`, `DEC A`.<br>• Extend microdemo with load/store.                                                                                                                     | Memory → CPU integration<br>• Connect memory inside CPU step using `read()` / `write()`.<br>• Demo file: `examples/mem_cpu_interop.py`.                                                                 | Harness v1<br>• Upgrade to step until PC reaches target.<br>• Dump full registers + RAM.<br>• Extend `tests/test_cpu_vs_pyboy.py` to validate `LD` ops.                                              |
| **4** | Interrupt & timer prep<br>• Add `IME`, `DI`, `EI` opcodes + timer regs (`DIV`, `TIMA`, etc.).<br>• Regenerate code with timer stubs.                                                                                                      | Timer component<br>• Write `prompts/timer_template.md` → `generated/timer.py`.<br>• Memory-map timer regs.<br>• Ensure `DIV` auto-increments.                                                           | Integration runner<br>• Build `cosim/run_vs_pyboy.py` to run emulator & PyBoy side-by-side for 5000 cycles.<br>• Log all mismatches.                                                                 |
| **5** | Joypad regs<br>• Add `joypad.registers` to spec + prompt → `generated/joypad.py`.<br>• Add input helper for test injection.                                                                                                              | MMU + Cartridge (MBC0)<br>• Update memory prompt to support ROM+RAM banks.<br>• Demo: CPU reads ROM header & jumps to entry.                                                                             | PPU LY counter<br>• In `ppu.py`, increment `LY` every 456 cycles.<br>• Compare LY trace vs PyBoy → `tests/test_ly_vs_pyboy.py`.                                                                      |
| **6** | APU stub & polish<br>• Add audio register block to spec + prompt (no audio logic).<br>• Ensure CPU ignores APU writes/reads safely.                                                                                                       | Game-ROM test<br>• Run `cpu_instrs` ROM for 20,000 cycles.<br>• Dump registers + RAM, compare to PyBoy.<br>• Report mismatches.                                                                         | Continuous diff output<br>• Enhance `run_vs_pyboy.py` to export CSV mismatch log per cycle.<br>• Upload as CI artifact.                                                                              |
| **7** | Final CPU polish<br>• Fix mismatches, finalize `cpu_template.md`.<br>• Add `docs/cpu_coverage.md` – opcode matrix + status.                                                                                                               | Memory documentation<br>• Finalize `docs/memory_map.md` and ensure full coverage.<br>• Clean up all prompts & tests.                                                                                    | Final demo + wrap-up<br>• Create `examples/run_full_loop.py`.<br>• Record GIF of emulator booting.<br>• Polish `README.md` + final slide deck.                                                       |



---

# Wrapping up tasks:


---
| Day             | Mentee A — CPU (generated/cpu.py)                                                                                                                                                                                                                                                                                                                | Mentee B — Minimal memory/HRAM                                                                                                                                                                                                                                                                                         | Mentee C — ROM & Harness run                                                                                                                                                                                                                                                            |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **D1**          | **Fix prompt & regenerate `cpu.py`** so the class exposes `A,F,B,C,D,E,H,L,SP,PC` (8-bit for A,F…; 16-bit PC/SP). Implement `step(instr)` that supports **exact mnemonics**: `LD_A_n8`, `ADD_A_n8`, `SUB_A_n8`, `LD_n8_A_ptr`, `LD_A_n8_ptr`, `HALT`. Update **only Z flag** where relevant; do **not** change PC inside `step()` for these ops. | Add **`ram = bytearray(0x80)`** to CPU for HRAM (0xFF80–0xFFFE). Inside CPU, implement helpers: `_ldh_read(n8)` and `_ldh_write(n8, val)` that map `n8 >= 0x80` → `ram[n8-0x80]`, else read returns `0xFF` and writes are ignored. No separate bus file needed for MVP.                                                | Create `examples/build_min_rom.py` that writes a **32 KB MBC0 ROM** with code at 0x0100: e.g., `LD A,5; ADD A,n8` or a tiny loop that also exercises `LDH`. Provide a one-liner to run: `python cosim/run_vs_pyboy.py out/min.gb 200`. Verify script launches headless PyBoy.           |
| **D2**          | Add **reset()** that zeros out regs and clears HRAM. Ensure all writes/read in `step()` mask to 8-bit (`& 0xFF`). Edge cases: `SUB` underflow wraps (two’s complement) still sets Z properly.                                                                                                                                                    | If needed by the ROM: add a trivial mirror for `0xFF44` (LY): keep a byte `ly` in CPU and expose `read_ly()` returning a simple incrementing value modulo 154 when `_ticks` advance (you can bump `_ticks` by a constant per `step`). This keeps PyBoy comparisons calmer if the ROM ever touches LY. Otherwise, skip. | Build the ROM and run: `python cosim/run_vs_pyboy.py out/min.gb 1000`. **Record mismatches.** If you see `HRAM[10]` mismatches, confirm we wrote `LDH (0x90),A` somewhere and that `cpu.ram[0x10]` matches. If opcodes show `UNIMPL_XX`, tell A to add that mnemonic or change the ROM. |
| **D3**          | Tighten flags for the used ops (ADD/SUB/INC if you add it). Make sure `F` only carries the Z bit (upper-bits masked) so it matches PyBoy’s reference pattern.                                                                                                                                                                                    | (Only if needed) add `self.io = bytearray(0x80)` and route `n8 < 0x80` to it to stabilize reads/writes; initialize it to `0xFF`. Keep it simple—no real devices this week.                                                                                                                                             | Rerun with higher step count (e.g., 5000). **Goal:** `mismatches=0`. Save the text output produced by the harness (it writes to `cosim/output_run_vs_pyboy.txt`). Put a 5-line “How to run” in `README.md`.                                                                             |
| **D4 (buffer)** | If PyBoy reports an opcode we don’t handle (e.g., `XOR A,A`), A adds one tiny case in `step()`. Keep to Z-flag only.                                                                                                                                                                                                                             | If we still see HRAM mismatches, print debug after `LDH` ops to confirm address mapping.                                                                                                                                                                                                                               | Final demo recording; commit prompts + generated files.                                                                                                                                                                                                                                 |


