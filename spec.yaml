# spec.yaml  ‚Äì Starter v0.1

name: GameBoy
version: 0.1

cpu:
  description: "8-bit Sharp LR35902 core (Intel 8080 + Z80 hybrid)"
  registers:
    A:   { bits: 8,  role: "Accumulator" }
    F:   { bits: 8,  role: "Flag register (Z N H C)" }
    PC:  { bits: 16, role: "Program Counter" }
  alu_ops:
    - { mnemonic: ADD_A_n8, operands: ["imm8"], effect: "A ‚Üê A + imm8" }
    - { mnemonic: SUB_A_n8, operands: ["imm8"], effect: "A ‚Üê A ‚Äì imm8" }
    - { mnemonic: AND_A_n8, operands: ["imm8"], effect: "A ‚Üê A & imm8" }
    - { mnemonic: OR_A_n8,  operands: ["imm8"], effect: "A ‚Üê A | imm8" }
    - { mnemonic: XOR_A_n8, operands: ["imm8"], effect: "A ‚Üê A ^ imm8" }
    - { mnemonic: INC_A,    operands: [],       effect: "A ‚Üê A + 1" }
    - { mnemonic: DEC_A,    operands: [],       effect: "A ‚Üê A - 1" }

  load_store_ops:
    - { mnemonic: LD_r_r,        operands: ["r1", "r2"], effect: "r1 ‚Üê r2" }
    - { mnemonic: LD_A_n8_ptr,   operands: ["n8"],       effect: "A ‚Üê [n8]" }
    - { mnemonic: LD_n8_A_ptr,   operands: ["n8"],       effect: "[n8] ‚Üê A" }

  control_ops:
    - { mnemonic: JP_a16,   operands: ["addr"],  effect: "PC ‚Üê addr" }
    - { mnemonic: JR_r8,    operands: ["rel8"],  effect: "PC ‚Üê PC + rel8" }
    - { mnemonic: CALL_a16, operands: ["addr"],  effect: "push(PC); PC ‚Üê addr" }
    - { mnemonic: RET,      operands: [],        effect: "PC ‚Üê pop()" }

joypad:
  description: "Joypad input register interface"
  registers:
    P1:
      addr: 0xFF00
      bits: 8
      role: "Joypad input: button selection and state (active low)"


memory:
  description: "Address map stub ‚Äì grow section by section"
  regions:
    - { name: ROM0,  base: 0x0000, size: 0x4000, readable: true, writable: false }
    - { name: ROMX,  base: 0x4000, size: 0x4000, readable: true, writable: false }
    - { name: VRAM,  base: 0x8000, size: 0x2000, readable: true, writable: true  }
    - { name: WRAM0, base: 0xC000, size: 0x1000, readable: true, writable: true  }
    - { name: WRAMX, base: 0xD000, size: 0x1000, readable: true, writable: true  }
    - { name: OAM,   base: 0xFE00, size: 0x00A0, readable: true, writable: true  }
    - { name: HRAM,  base: 0xFF80, size: 0x007F, readable: true, writable: true  }

    # üïí Week 4 ‚Äì Timer-mapped I/O registers
    - { name: TIMER_DIV,  base: 0xFF04, size: 1, readable: true, writable: true }
    - { name: TIMER_TIMA, base: 0xFF05, size: 1, readable: true, writable: true }
    - { name: TIMER_TMA,  base: 0xFF06, size: 1, readable: true, writable: true }
    - { name: TIMER_TAC,  base: 0xFF07, size: 1, readable: true, writable: true }

ppu:
  description: "LCD controller registers only for now"
  registers:
    LY:   { addr: 0xFF44, bits: 8, role: "Current scanline" }
    LCDC: { addr: 0xFF40, bits: 8, role: "LCD control" }
    STAT: { addr: 0xFF41, bits: 8, role: "LCD status flags & mode" }
    SCY:  { addr: 0xFF42, bits: 8, role: "BG viewport Y scroll" }
    SCX:  { addr: 0xFF43, bits: 8, role: "BG viewport X scroll" }
    WY:   { addr: 0xFF4A, bits: 8, role: "Window Y position" }
    WX:   { addr: 0xFF4B, bits: 8, role: "Window X position plus 7" }

memory_cpu_integration:
  description: |
    Connect the Memory system to the CPU so that the CPU uses
    Memory's read(addr) and write(addr, value) methods for all
    memory access.

  tasks:
    - Implement a Memory class with read() and write() methods
      that correctly route reads/writes to memory regions based on address.
    - Modify the CPU class to accept a Memory instance and
      call memory.read(addr) and memory.write(addr, value) when accessing memory.
    - Ensure errors are raised for invalid addresses or illegal writes (e.g., to ROM).
    - Test integration by running the provided demo file:
      examples/mem_cpu_interop.py

